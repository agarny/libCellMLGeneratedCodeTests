#include "common.h"

extern "C" {
#include "model.h"
}

#include <cvode/cvode.h>
#include <nvector/nvector_serial.h>
#include <sunlinsol/sunlinsol_dense.h>

#include <iostream>

void printInformation()
{
    std::cout << "---------------------------------------[Information][BEGIN]" << std::endl;
    std::cout << "- Generator version: " << VERSION << std::endl;
    std::cout << "- libCellML version: " << LIBCELLML_VERSION << std::endl;
    std::cout << "---------------------------------------" << std::endl;
    std::cout << "- Variable of integration:" << std::endl;
    std::cout << "   - " << VOI_INFO.component << "." << VOI_INFO.name << " [" << VOI_INFO.units << "]" << std::endl;
    std::cout << "---------------------------------------" << std::endl;
    std::cout << "- Number of states: " << STATE_COUNT << std::endl;
    std::cout << "- States:" << std::endl;

    for (size_t i = 0; i < STATE_COUNT; ++i) {
        std::cout << "   - " << STATE_INFO[i].component << "." << STATE_INFO[i].name << " [" << STATE_INFO[i].units << "]" << std::endl;
    }

    std::cout << "---------------------------------------" << std::endl;
    std::cout << "- Number of constants: " << CONSTANT_COUNT << std::endl;
    std::cout << "- Constants:" << std::endl;

    for (size_t i = 0; i < CONSTANT_COUNT; ++i) {
        std::cout << "   - " << CONSTANT_INFO[i].component << "." << CONSTANT_INFO[i].name << " [" << CONSTANT_INFO[i].units << "]" << std::endl;
    }

    std::cout << "---------------------------------------" << std::endl;
    std::cout << "- Number of computed constants: " << COMPUTED_CONSTANT_COUNT << std::endl;
    std::cout << "- Computed constants:" << std::endl;

    for (size_t i = 0; i < COMPUTED_CONSTANT_COUNT; ++i) {
        std::cout << "   - " << COMPUTED_CONSTANT_INFO[i].component << "." << COMPUTED_CONSTANT_INFO[i].name << " [" << COMPUTED_CONSTANT_INFO[i].units << "]" << std::endl;
    }

    std::cout << "---------------------------------------" << std::endl;
    std::cout << "- Number of algebraic variables: " << ALGEBRAIC_COUNT << std::endl;
    std::cout << "- Algebraic variables:" << std::endl;

    for (size_t i = 0; i < ALGEBRAIC_COUNT; ++i) {
        std::cout << "   - " << ALGEBRAIC_INFO[i].component << "." << ALGEBRAIC_INFO[i].name << " [" << ALGEBRAIC_INFO[i].units << "]" << std::endl;
    }

    std::cout << "---------------------------------------[Information][END]" << std::endl;
}

void printHeaders()
{
    std::cout << "voi";

    for (size_t i = 0; i < STATE_COUNT; ++i) {
        std::cout << "," << STATE_INFO[i].name;
    }

    for (size_t i = 0; i < CONSTANT_COUNT; ++i) {
        std::cout << "," << CONSTANT_INFO[i].name;
    }

    for (size_t i = 0; i < COMPUTED_CONSTANT_COUNT; ++i) {
        std::cout << "," << COMPUTED_CONSTANT_INFO[i].name;
    }

    for (size_t i = 0; i < ALGEBRAIC_COUNT; ++i) {
        std::cout << "," << ALGEBRAIC_INFO[i].name;
    }

    std::cout << std::endl;
}

void printValues(double voi, const double *states, const double *constants, const double *computedConstants, const double *algebraic)
{
    std::cout << voi;

    for (size_t i = 0; i < STATE_COUNT; ++i) {
        std::cout << "," << states[i];
    }

    for (size_t i = 0; i < CONSTANT_COUNT; ++i) {
        std::cout << "," << constants[i];
    }

    for (size_t i = 0; i < COMPUTED_CONSTANT_COUNT; ++i) {
        std::cout << "," << computedConstants[i];
    }

    for (size_t i = 0; i < ALGEBRAIC_COUNT; ++i) {
        std::cout << "," << algebraic[i];
    }

    std::cout << std::endl;
}

typedef struct {
    void (*computeRates)(double, double *, double *, double *, double *, double *);

    double *constants;
    double *computedConstants;
    double *algebraic;
} UserOdeData;

int func(double voi, N_Vector y, N_Vector yDot, void *userData)
{
    UserOdeData *realUserData = (UserOdeData *) userData;

    realUserData->computeRates(voi, N_VGetArrayPointer_Serial(y), N_VGetArrayPointer_Serial(yDot), realUserData->constants, realUserData->computedConstants, realUserData->algebraic);

    return 0;
}

int main()
{
    // Some information about the model.

    printInformation();

    // Create our various arrays.

    double voi = 0.0;
    double *states = createStatesArray();
    double *rates = createStatesArray();
    double *constants = createConstantsArray();
    double *computedConstants = createComputedConstantsArray();
    double *algebraic = createAlgebraicArray();

    // Initialise our states, rates, constants, computed constants, and algebraic variables and output their initial
    // value/guess.

    initialiseVariables(states, rates, constants, computedConstants, algebraic);
    computeComputedConstants(constants, computedConstants);
    computeRates(voi, states, rates, constants, computedConstants, algebraic);
    computeVariables(voi, states, rates, constants, computedConstants, algebraic);

    std::cout << std::endl;
    std::cout << "---------------------------------------[Values][BEGIN]" << std::endl;

    printHeaders();

    if (!@SKIP_FIRST_OUTPUT_POINT@) {
        printValues(voi, states, constants, computedConstants, algebraic);
    }

    // Create our SUNDIALS context.

    SUNContext context;

    SUNContext_Create(0, &context);

    // Create our CVODE solver.

    void *solver = CVodeCreate(CV_BDF, context);

    // Initialise our CVODE solver.

    N_Vector y = N_VMake_Serial(STATE_COUNT, states, context);

    CVodeInit(solver, func, voi, y);

    // Set our user data.

    UserOdeData userData = { computeRates, constants, computedConstants, algebraic };

    CVodeSetUserData(solver, &userData);

    // Set our maximum number of steps.

    CVodeSetMaxNumSteps(solver, 99999);

    // Set our linear solver.

    SUNMatrix matrix = SUNDenseMatrix(STATE_COUNT, STATE_COUNT, context);
    SUNLinearSolver linearSolver = SUNLinSol_Dense(y, matrix, context);

    CVodeSetLinearSolver(solver, linearSolver, matrix);

    // Set our relative and absolute tolerances.

    CVodeSStolerances(solver, @RELATIVE_TOLERANCE@, @ABSOLUTE_TOLERANCE@);

    // Run our model.

    std::vector<double> outputPoints = @OUTPUT_POINTS@;

    if (!@USE_OUTPUT_POINTS@) {
        size_t i = 0;
        double voiMax = @ENDING_POINT@;
        double voiInterval = @POINT_INTERVAL@;

        do {
            voi = ++i * voiInterval;

            outputPoints.push_back(voi);
        } while (voi < voiMax);
    }

    for (const auto &outputPoint : outputPoints) {
        // Integrate our model.

        CVode(solver, outputPoint, y, &voi, CV_NORMAL);

        // Compute our variables.

        computeVariables(voi, states, rates, constants, computedConstants, algebraic);

        // Output the value of our states, constants, computed constants, and algebraic variables.

        printValues(voi, states, constants, computedConstants, algebraic);
    }

    std::cout << "---------------------------------------[Values][END]" << std::endl;

    // Clean up after ourselves.

    SUNLinSolFree(linearSolver);
    SUNMatDestroy(matrix);
    N_VDestroy_Serial(y);
    CVodeFree(&solver);
    SUNContext_Free(&context);

    deleteArray(states);
    deleteArray(rates);
    deleteArray(constants);
    deleteArray(computedConstants);
    deleteArray(algebraic);

    return 0;
}
